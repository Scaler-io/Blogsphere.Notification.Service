parameters:
  projects: ""
  buildConfiguration: "Release"

steps:
  # Download build artifacts from previous stage
  - download: current
    artifact: build-output
    displayName: "Download Build Artifacts"

  # Security analysis
  - task: PowerShell@2
    displayName: "Security Analysis - Check Vulnerable Packages"
    inputs:
      targetType: "inline"
      script: |
        Write-Host "üîç Checking for vulnerable packages..."

        # Check current directory structure
        Write-Host "üìÅ Current directory: $(Get-Location)"
        Write-Host "üìÅ Available directories:"
        Get-ChildItem -Directory | ForEach-Object { Write-Host "  - $($_.Name)" }

        # Look for the project file in various possible locations
        $possiblePaths = @(
          "src/Blogsphere.Notification.Service",
          "Blogsphere.Notification.Service",
          ".",
          "build-output"
        )

        $projectFound = $false
        foreach ($path in $possiblePaths) {
          if (Test-Path $path) {
            Write-Host "üìÅ Checking path: $path"
            $csprojFiles = Get-ChildItem -Path $path -Filter "*.csproj" -Recurse
            if ($csprojFiles) {
              Write-Host "‚úÖ Found project file in: $path"
              Set-Location $path
              Write-Host "üìÅ Working directory: $(Get-Location)"
              
              # Check for vulnerable packages
              $vulnerablePackages = dotnet list package --vulnerable 2>&1
              
              if ($LASTEXITCODE -eq 0) {
                Write-Host "‚úÖ No vulnerable packages found"
              } else {
                Write-Host "‚ö†Ô∏è Vulnerable packages detected:"
                Write-Host $vulnerablePackages
              }
              
              $projectFound = $true
              break
            }
          }
        }

        if (-not $projectFound) {
          Write-Host "‚ùå No project file found in any expected location"
          Write-Host "üìÅ All files in current directory:"
          Get-ChildItem -Recurse | ForEach-Object { Write-Host "  - $($_.FullName)" }
        }

  # Code quality analysis
  - task: PowerShell@2
    displayName: "Code Quality Analysis"
    inputs:
      targetType: "inline"
      script: |
        Write-Host "üîç Running code quality checks..."

        # Look for the project file in various possible locations
        $possiblePaths = @(
          "src/Blogsphere.Notification.Service",
          "Blogsphere.Notification.Service",
          ".",
          "build-output"
        )

        $projectFound = $false
        foreach ($path in $possiblePaths) {
          if (Test-Path $path) {
            Write-Host "üìÅ Checking path: $path"
            $csprojFiles = Get-ChildItem -Path $path -Filter "*.csproj" -Recurse
            if ($csprojFiles) {
              Write-Host "‚úÖ Found project file in: $path"
              Set-Location $path
              Write-Host "üìÅ Working directory: $(Get-Location)"
              
              # Check for compiler warnings and errors
              $buildOutput = dotnet build --configuration ${{ parameters.buildConfiguration }} --verbosity normal 2>&1
              $warnings = $buildOutput | Select-String "warning"
              $errors = $buildOutput | Select-String "error"
              
              if ($errors) {
                Write-Host "‚ùå Found $($errors.Count) errors:"
                $errors | ForEach-Object { Write-Host "  $_" }
                exit 1
              }
              
              if ($warnings) {
                Write-Host "‚ö†Ô∏è Found $($warnings.Count) warnings:"
                $warnings | ForEach-Object { Write-Host "  $_" }
              } else {
                Write-Host "‚úÖ No warnings found"
              }
              
              # Check for code style issues (if StyleCop is configured)
              Write-Host "üìã Checking code style..."
              # dotnet tool install --global StyleCop.Analyzers
              # dotnet stylecop
              
              $projectFound = $true
              break
            }
          }
        }

        if (-not $projectFound) {
          Write-Host "‚ùå No project file found for code quality analysis"
        }

  # Dependency analysis
  - task: PowerShell@2
    displayName: "Dependency Analysis"
    inputs:
      targetType: "inline"
      script: |
        Write-Host "üì¶ Analyzing dependencies..."

        # Look for the project file in various possible locations
        $possiblePaths = @(
          "src/Blogsphere.Notification.Service",
          "Blogsphere.Notification.Service",
          ".",
          "build-output"
        )

        $projectFound = $false
        foreach ($path in $possiblePaths) {
          if (Test-Path $path) {
            Write-Host "üìÅ Checking path: $path"
            $csprojFiles = Get-ChildItem -Path $path -Filter "*.csproj" -Recurse
            if ($csprojFiles) {
              Write-Host "‚úÖ Found project file in: $path"
              Set-Location $path
              Write-Host "üìÅ Working directory: $(Get-Location)"
              
              # List all packages
              Write-Host "Installed packages:"
              dotnet list package
              
              # Check for outdated packages
              Write-Host "`nChecking for outdated packages..."
              dotnet list package --outdated
              
              $projectFound = $true
              break
            }
          }
        }

        if (-not $projectFound) {
          Write-Host "‚ùå No project file found for dependency analysis"
        }

  # Code metrics (if available)
  - task: PowerShell@2
    displayName: "Code Metrics Analysis"
    inputs:
      targetType: "inline"
      script: |
        Write-Host "üìä Analyzing code metrics..."

        # Count lines of code (basic metric)
        $csFiles = Get-ChildItem -Path "src" -Filter "*.cs" -Recurse
        $totalLines = 0

        foreach ($file in $csFiles) {
          $lines = Get-Content $file.FullName | Measure-Object -Line
          $totalLines += $lines.Lines
        }

        Write-Host "üìà Total lines of C# code: $totalLines"
        Write-Host "üìÅ Total C# files: $($csFiles.Count)"

  # Upload analysis results
  - task: PublishBuildArtifacts@1
    displayName: "Publish Analysis Results"
    inputs:
      pathToPublish: "src"
      artifactName: "CodeAnalysisResults"
    condition: succeededOrFailed()
