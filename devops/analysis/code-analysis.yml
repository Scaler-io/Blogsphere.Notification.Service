parameters:
  projects: ""
  buildConfiguration: "Release"

steps:
  # Download build artifacts from previous stage
  - download: current
    artifact: build-output
    displayName: "Download Build Artifacts"

  # Security analysis
  - task: PowerShell@2
    displayName: "Security Analysis - Check Vulnerable Packages"
    inputs:
      targetType: "inline"
      script: |
        Write-Host "üîç Checking for vulnerable packages..."

        # Navigate to the project directory
        $projectPath = "src/Blogsphere.Notification.Service"
        if (Test-Path $projectPath) {
          Set-Location $projectPath
          Write-Host "üìÅ Working directory: $(Get-Location)"
          
          # Check for vulnerable packages
          $vulnerablePackages = dotnet list package --vulnerable 2>&1
          
          if ($LASTEXITCODE -eq 0) {
            Write-Host "‚úÖ No vulnerable packages found"
          } else {
            Write-Host "‚ö†Ô∏è Vulnerable packages detected:"
            Write-Host $vulnerablePackages
          }
        } else {
          Write-Host "‚ùå Project directory not found: $projectPath"
          Write-Host "Available directories:"
          Get-ChildItem -Directory | ForEach-Object { Write-Host "  - $($_.Name)" }
        }

  # Code quality analysis
  - task: PowerShell@2
    displayName: "Code Quality Analysis"
    inputs:
      targetType: "inline"
      script: |
        Write-Host "üîç Running code quality checks..."

        # Navigate to the project directory
        $projectPath = "src/Blogsphere.Notification.Service"
        if (Test-Path $projectPath) {
          Set-Location $projectPath
          Write-Host "üìÅ Working directory: $(Get-Location)"
          
          # Check for compiler warnings and errors
          $buildOutput = dotnet build --configuration ${{ parameters.buildConfiguration }} --verbosity normal 2>&1
          $warnings = $buildOutput | Select-String "warning"
          $errors = $buildOutput | Select-String "error"
          
          if ($errors) {
            Write-Host "‚ùå Found $($errors.Count) errors:"
            $errors | ForEach-Object { Write-Host "  $_" }
            exit 1
          }
          
          if ($warnings) {
            Write-Host "‚ö†Ô∏è Found $($warnings.Count) warnings:"
            $warnings | ForEach-Object { Write-Host "  $_" }
          } else {
            Write-Host "‚úÖ No warnings found"
          }
          
          # Check for code style issues (if StyleCop is configured)
          Write-Host "üìã Checking code style..."
          # dotnet tool install --global StyleCop.Analyzers
          # dotnet stylecop
        } else {
          Write-Host "‚ùå Project directory not found: $projectPath"
          Write-Host "Available directories:"
          Get-ChildItem -Directory | ForEach-Object { Write-Host "  - $($_.Name)" }
        }

  # Dependency analysis
  - task: PowerShell@2
    displayName: "Dependency Analysis"
    inputs:
      targetType: "inline"
      script: |
        Write-Host "üì¶ Analyzing dependencies..."

        # Navigate to the project directory
        $projectPath = "src/Blogsphere.Notification.Service"
        if (Test-Path $projectPath) {
          Set-Location $projectPath
          Write-Host "üìÅ Working directory: $(Get-Location)"
          
          # List all packages
          Write-Host "Installed packages:"
          dotnet list package
          
          # Check for outdated packages
          Write-Host "`nChecking for outdated packages..."
          dotnet list package --outdated
        } else {
          Write-Host "‚ùå Project directory not found: $projectPath"
          Write-Host "Available directories:"
          Get-ChildItem -Directory | ForEach-Object { Write-Host "  - $($_.Name)" }
        }

  # Code metrics (if available)
  - task: PowerShell@2
    displayName: "Code Metrics Analysis"
    inputs:
      targetType: "inline"
      script: |
        Write-Host "üìä Analyzing code metrics..."

        # Count lines of code (basic metric)
        $csFiles = Get-ChildItem -Path "src" -Filter "*.cs" -Recurse
        $totalLines = 0

        foreach ($file in $csFiles) {
          $lines = Get-Content $file.FullName | Measure-Object -Line
          $totalLines += $lines.Lines
        }

        Write-Host "üìà Total lines of C# code: $totalLines"
        Write-Host "üìÅ Total C# files: $($csFiles.Count)"

  # Upload analysis results
  - task: PublishBuildArtifacts@1
    displayName: "Publish Analysis Results"
    inputs:
      pathToPublish: "src"
      artifactName: "CodeAnalysisResults"
    condition: succeededOrFailed()
